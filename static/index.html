<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- Responsive viewport -->
    <title>Video Shorts Generator</title>
    <!-- Consider linking a separate CSS file for better organization -->
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <h1>Video Shorts Generator</h1>
    <!-- Dark Mode Toggle Start -->
    <div class="theme-switch-wrapper">
        <label class="theme-switch" for="darkModeToggle">
            <input type="checkbox" id="darkModeToggle" />
            <span class="slider round"></span>
        </label>
        <em>Toggle Dark Mode</em>
    </div>
    <!-- Added container div for upload section styling -->
    <div id="uploadSectionContainer">
        <div id="uploadSection">
             <h2>Upload New Video</h2>
             <form id="uploadForm" enctype="multipart/form-data">
                 <div>
                     <label for="video">1. Select Video File (Required):</label>
                     <input type="file" id="video" name="video" accept="video/*,.mkv,.mov,.avi,.wmv" required>
                 </div>
                 <div>
                     <label for="subtitle">2. Select Subtitle File (Optional .srt/.vtt):</label>
                     <input type="file" id="subtitle" name="subtitle" accept=".srt,.vtt">
                 </div>
                 <div>
                     <label for="zoomFactor">3. Zoom Factor (e.g., 1.5, 2.0):</label>
                     <input type="number" id="zoomFactor" name="zoom_factor" step="0.1" min="1" value="2.0"> <!-- Added zoom factor input -->
                 </div>
                 <button type="submit">Upload & Process</button>
             </form>
             <div id="uploadStatus" class="status"></div>
         </div>
    </div>


    <!-- Removed HR, using section spacing instead -->
    <!-- <hr> -->

    <!-- Added container div for table section styling -->
    <div id="videosTableContainer">
        <h2>Manage Videos</h2>
        <div id="listStatus" class="status"></div>
        <!-- Table itself is inside -->
        <table id="videosTable">
            <thead>
                <tr>
                    <th>ID</th>
                    <th>Details</th>
                    <th>Full Video</th>
                    <th>Shorts</th>
                    <th>Actions & Subtitles</th>
                </tr>
            </thead>
            <tbody><!-- Video rows will be inserted here --></tbody>
        </table>
    </div>

    <!-- Shorts Modal -->
    <div id="shortsModal" class="modal">
        <div class="modal-content" id="shortsModalContent">
            <button class="close-button" onclick="closeShortsModal()" aria-label="Close Modal">×</button>
            <h3 id="shortsModalTitle">Shorts</h3>
             <div id="shortsModalStatus" class="status"></div>
            <div id="shortsList">
                 <!-- Short items will be inserted here -->
            </div>
        </div>
    </div>

    <!-- Video Player Modal -->
    <div id="videoModal" class="modal">
        <div class="modal-content" id="videoModalContent">
            <button class="close-button" onclick="closeVideoModal()" aria-label="Close Player">×</button>
             <h4 id="videoModalTitle" style='margin-top:0; margin-bottom: 10px;'>Video Player</h4>
            <video id="modalVideo" controls controlsList="nodownload"></video> <!-- Added controlsList -->
        </div>
    </div>

    <script>
        // Store video data locally
        let videosData = {};
        // Track modal state and refresh interval
        let currentModalVideoId = null;
        let refreshIntervalId = null; // Interval ID for clearing
        const REFRESH_INTERVAL_MS = 7000; // Refresh every 7 seconds
        const toggleSwitch = document.getElementById('darkModeToggle');
        const currentTheme = localStorage.getItem('theme');

        function setTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
            if (toggleSwitch) {
                 toggleSwitch.checked = theme === 'dark';
            }
             // Optional: Dispatch an event if other components need to react
             // document.dispatchEvent(new CustomEvent('themeChanged', { detail: { theme: theme } }));
        }

        // Apply the saved theme or the preferred scheme on initial load
        if (currentTheme) {
            setTheme(currentTheme);
        } else {
            // Check for OS preference
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            setTheme(prefersDark ? 'dark' : 'light');
        }

        // Listener for the toggle switch
        if (toggleSwitch) {
            toggleSwitch.addEventListener('change', function(e) {
                setTheme(e.target.checked ? 'dark' : 'light');
            });
        }

        // Optional: Listen for OS preference changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
            // Only change if no theme is manually set in localStorage
            if (!localStorage.getItem('theme')) {
                setTheme(e.matches ? 'dark' : 'light');
            }
        });
        // --- Utility Functions ---
        function setStatus(elementId, message, isError = false, duration = 5000) {
            const element = document.getElementById(elementId);
            if (!element) return;

            element.textContent = message;
            // Determine status class based on error or specific message content
            let statusClass = 'status-info'; // Default info style
            if (isError) {
                statusClass = 'status-failed';
            } else if (!message) { // Clear status
                statusClass = '';
            } else if (message.toLowerCase().includes('processing') || message.toLowerCase().includes('queued') || message.toLowerCase().includes('refreshing') || message.toLowerCase().includes('waiting') || message.toLowerCase().includes('started') || message.toLowerCase().includes('uploading')) {
                 statusClass = 'status-processing';
            } else if (message.toLowerCase().includes('complete') || message.toLowerCase().includes('success') || message.toLowerCase().includes('loaded') || message.toLowerCase().includes('uploaded') || message.toLowerCase().includes('updated') || message.toLowerCase().includes('deleted')) {
                 statusClass = 'status-completed';
            } else if (message.toLowerCase().includes('pending_reprocess')) {
                 statusClass = 'status-pending_reprocess';
            } else if (message.toLowerCase().includes('pending')) {
                 statusClass = 'status-pending';
            }
            // Add other keywords if needed

            // Reset classes and add the determined status class
            element.className = 'status'; // Reset to base class first
            if(statusClass) {
                element.classList.add(statusClass);
            }

            // Clear status after a delay (if duration > 0)
            if (message && duration > 0) {
                setTimeout(() => {
                    // Check if the message is still the same before clearing
                    if (element.textContent === message) {
                        element.textContent = '';
                        element.className = 'status'; // Reset class
                    }
                }, duration);
            } else if (!message) {
                 // If message is empty, clear immediately and reset class
                 element.textContent = '';
                 element.className = 'status';
            }
        }

        function getVideoStatusClass(status) {
            // Ensure status is a string and handle null/undefined
            const statusStr = String(status || 'pending').toLowerCase().replace(/\s+/g, '_');
            return `status-${statusStr}`;
        }

        // Debounce function to limit rapid calls (e.g., for refresh)
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // --- API Fetch Functions ---
        async function fetchWithCacheBust(url, options = {}) {
             // Add cache-busting query parameter
             const separator = url.includes('?') ? '&' : '?';
             const cacheBustedUrl = `${url}${separator}_=${new Date().getTime()}`; // Use underscore for convention
             try {
                 const response = await fetch(cacheBustedUrl, options);
                 // No explicit error handling here, let caller handle non-ok responses
                 return response;
             } catch (networkError) {
                 console.error('Network error fetching:', url, networkError);
                 // Rethrow or handle as appropriate for the caller
                 throw new Error(`Network error: ${networkError.message}`);
             }
        }

        async function fetchVideos() {
            setStatus('listStatus', 'Loading videos...', false, 0); // Persistent until loaded or error
            try {
                const response = await fetchWithCacheBust('/videos');
                if (!response.ok) {
                    // Try to parse error JSON, fallback to status text
                    const errorData = await response.json().catch(() => ({ error: `HTTP error! Status: ${response.status}` }));
                    throw new Error(errorData.error || `HTTP error! Status: ${response.status}`);
                }
                const videos = await response.json();
                setStatus('listStatus', `Loaded ${videos.length} videos.`, false, 5000); // Success message disappears
                return videos;
            } catch (error) {
                console.error('Error loading videos:', error);
                setStatus('listStatus', `Error loading videos: ${error.message}`, true, 0); // Persistent error
                return []; // Return empty array on error
            }
        }

        async function fetchShortsForVideo(videoId) {
             // Using shortsModalStatus for feedback during modal operations
             console.log(`Fetching shorts for video ${videoId}`);
             setStatus('shortsModalStatus', 'Refreshing shorts...', false, 0); // Indicate loading
             try {
                const response = await fetchWithCacheBust(`/videos/${videoId}/shorts`);
                if (!response.ok) {
                     // Try to parse error JSON, fallback to status text
                     const errorData = await response.json().catch(() => ({ error: `HTTP error! Status: ${response.status}` }));
                     throw new Error(errorData.error || `HTTP error! Status: ${response.status}`);
                }
                 const shorts = await response.json();
                 setStatus('shortsModalStatus', ''); // Clear status on success
                 return shorts;
             } catch (error) {
                 console.error(`Error loading shorts for video ${videoId}:`, error);
                 setStatus('shortsModalStatus', `Error refreshing shorts: ${error.message}`, true, 0); // Persistent error
                 // Return cached data if available, otherwise empty
                 return videosData[videoId]?.shorts || [];
             }
        }

        // --- UI Rendering ---
        function renderVideosTable(videos) {
            const tbody = document.querySelector('#videosTable tbody');
            tbody.innerHTML = ''; // Clear existing rows
            videosData = {}; // Reset local cache

            if (!videos || videos.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; padding: 20px; font-style: italic;">No videos found. Upload a video to get started.</td></tr>';
                return;
            }

            // Sort videos by ID descending (newest first) - optional
            videos.sort((a, b) => b.id - a.id);

            videos.forEach(video => {
                videosData[video.id] = video; // Store/update video data by ID
                const row = document.createElement('tr');
                row.dataset.videoId = video.id;

                // Determine states for button logic
                const isCompleted = video.status === 'completed';
                const isProcessing = ['processing', 'pending', 'queued', 'pending_reprocess'].includes(video.status);
                const isFailed = video.status === 'failed';
                const hasUploadedSubs = !!video.uploaded_subtitle_filename;
                // Ensure shorts is an array before checking length
                const shortsArray = Array.isArray(video.shorts) ? video.shorts : [];
                const hasShorts = shortsArray.length > 0;
                // Use the backend flag for suggestibility
                const hasSuggestibleContent = video.has_subtitle_content === true;

                // --- Shorts Button Logic ---
                let shortsButtonText = 'Manage Shorts';
                let shortsButtonDisabled = !isCompleted; // Disabled if not completed
                let shortsButtonTitle = isCompleted ? 'View, manage, or suggest shorts' : 'Video processing must be complete';
                let shortsButtonSmallText = ''; // Additional text below button

                if (isCompleted) {
                    if (hasShorts) {
                        shortsButtonText = `View ${shortsArray.length} Shorts`;
                    } else if (hasSuggestibleContent) {
                        shortsButtonText = 'Suggest Shorts';
                        shortsButtonTitle = 'Generate short suggestions based on available subtitles';
                        shortsButtonSmallText = '(Click to suggest)';
                    } else {
                        shortsButtonText = 'View Shorts'; // No shorts & no content
                        shortsButtonTitle = 'View shorts (No subtitle content found to suggest new ones)';
                        shortsButtonSmallText = '(No shorts/content)';
                    }
                } else if (isProcessing) {
                     shortsButtonTitle = `Cannot manage shorts while status is ${video.status}`;
                } else if (isFailed) {
                     shortsButtonTitle = 'Video processing failed, cannot manage shorts';
                }

                // --- Action Buttons Visibility/State ---
                const canPerformActions = isCompleted || isFailed; // Allow delete/reprocess on completion or failure
                const canReprocess = isCompleted || isFailed;
                const canReprocessWithSubs = canReprocess && hasUploadedSubs; // Need uploaded subs
                const canReprocessSuggestions = isCompleted && hasSuggestibleContent; // Need completion and content
                const canUploadSubs = !isProcessing; // Can upload unless actively processing

                // --- Build Row HTML ---
                row.innerHTML = `
                    <td>${video.id}</td>
                    <td>
                        <strong>${video.title || 'Untitled Video'}</strong><br>
                        <small title="${video.original_filename}">Filename: ${video.original_filename}</small><br>
                        Status: <strong class="${getVideoStatusClass(video.status)}">${video.status}</strong>
                        ${hasUploadedSubs
                            ? `<br><small title="Using uploaded subtitle: ${video.uploaded_subtitle_filename}">Using Subs: ${video.uploaded_subtitle_filename.substring(0, 20)}${video.uploaded_subtitle_filename.length > 20 ? '...' : ''}</small>`
                            : ''}
                        ${!hasUploadedSubs && video.status === 'completed' && video.has_subtitle_content
                            ? `<br><small>Using Generated Subs</small>`
                            : ''}
                         ${video.status === 'failed' && video.error_message
                            ? `<br><small style="color: var(--danger-color);" title="${video.error_message}">Error: ${video.error_message.substring(0, 50)}${video.error_message.length > 50 ? '...' : ''}</small>` : ''}
                    </td>
                    <td style="text-align: center;">
                        <button onclick="playVideo('${video.edited_video_url}', 'Full Video: ${(video.title || video.original_filename).replace(/'/g, "\\'")}')" ${!video.edited_video_url || isProcessing ? 'disabled' : ''} title="${video.edited_video_url && !isProcessing ? 'Play the full edited video' : (isProcessing ? 'Video processing' : 'Video not available')}">
                            Play Full
                        </button>
                    </td>
                    <td style="text-align: center;">
                        <button onclick="showShorts(${video.id})" ${shortsButtonDisabled} title="${shortsButtonTitle}">
                            ${shortsButtonText}
                        </button>
                        ${shortsButtonSmallText ? `<br><small>${shortsButtonSmallText}</small>` : ''}
                    </td>
                    <td>
                         <div class="button-group">
                            <button class="danger" onclick="deleteVideo(${video.id})" title="Delete video and all related files">Delete</button>
                            <button onclick="reprocessSuggestions(${video.id})" ${!canReprocessSuggestions ? 'disabled' : ''} title="${canReprocessSuggestions ? 'Generate new short suggestions using current subtitle content' : 'Requires completed video with subtitle content'}">Regen Suggestions</button>
                            <button onclick="reprocessAllAutoDetect(${video.id})" ${!canReprocess ? 'disabled' : ''} title="${canReprocess ? 'Re-process all: Subtitles (auto), video edit, suggestions' : 'Cannot reprocess in current state'}">Reprocess All (Auto)</button>
                            <button onclick="triggerReprocessWithSubs(${video.id})" ${!canReprocessWithSubs ? 'disabled' : ''} title="${canReprocessWithSubs ? 'Force re-process all using the previously uploaded subtitle file' : 'Requires uploaded subs & completed/failed state'}">Reprocess All (Use Subs)</button>
                         </div>
                        <!-- Subtitle Upload Form -->
                        <form class="subtitle-upload-form" data-video-id="${video.id}" onsubmit="uploadExistingVideoSubtitle(event)">
                            <label for="subtitle-upload-${video.id}">New Subs:</label>
                            <input type="file" id="subtitle-upload-${video.id}" name="subtitle" accept=".srt,.vtt" ${!canUploadSubs ? 'disabled' : ''} title="${canUploadSubs ? 'Upload new SRT/VTT (replaces existing, triggers reprocessing)' : 'Cannot upload subs while processing'}">
                            <button type="submit" ${!canUploadSubs ? 'disabled' : ''} title="Upload and reprocess with new subtitles">Upload Subs</button>
                        </form>
                    </td>
                `;
                tbody.appendChild(row);
            });
        }

        // Debounced version for refresh calls to avoid rapid re-renders
        const debouncedLoadAndRender = debounce(loadAndRenderVideos, 500); // 500ms delay

        // --- Main Load and Render Function ---
        async function loadAndRenderVideos() {
             const videos = await fetchVideos(); // Fetch latest video list
             renderVideosTable(videos); // Render the table UI

             // --- Handle Modal Refresh Logic ---
             if (currentModalVideoId && videosData[currentModalVideoId]) {
                 // If a shorts modal is open and its video still exists
                 const video = videosData[currentModalVideoId]; // Get updated data for the modal's video

                 // Update modal status based on the main video's status
                 if (isProcessingStatus(video.status)) {
                      setStatus('shortsModalStatus', `Main video status: ${video.status}. Waiting...`, false, 0);
                 } else if (video.status === 'failed') {
                      setStatus('shortsModalStatus', `Main video processing failed. ${video.error_message || ''}`, true, 0);
                 } else if (video.status === 'completed') {
                      // Video completed. Check if shorts need updating within the modal.
                      const shortsNeedUpdate = shouldRefreshShorts(video.shorts); // Check if any short is processing/queued
                      const suggestibleNow = video.has_subtitle_content && (!video.shorts || video.shorts.length === 0);

                      if (shortsNeedUpdate || suggestibleNow) {
                           console.log(`Modal video ${currentModalVideoId} completed or shorts processing, refreshing shorts list.`);
                           const shorts = await fetchShortsForVideo(currentModalVideoId); // Fetch updated shorts
                           videosData[currentModalVideoId].shorts = shorts; // Update local cache
                           updateShortsModal(currentModalVideoId); // Re-render the modal content
                           // Status is cleared by fetchShortsForVideo on success
                      } else {
                           // If processing finished and no shorts needed update, ensure status is clear
                           const statusElement = document.getElementById('shortsModalStatus');
                           if (statusElement && statusElement.textContent.includes('Waiting')) {
                                setStatus('shortsModalStatus', ''); // Clear "Waiting..." message
                           }
                      }
                 }
             } else if (currentModalVideoId && !videosData[currentModalVideoId]) {
                 // If the video for the open modal was deleted/removed from the list
                 console.warn(`Video ${currentModalVideoId} for open modal not found in latest fetch. Closing modal.`);
                 closeShortsModal();
             }
        }

        // Helper to check if a video status indicates processing
        function isProcessingStatus(status) {
            return ['processing', 'pending', 'queued', 'pending_reprocess'].includes(status);
        }

        // Helper to check if shorts list contains items needing refresh
        function shouldRefreshShorts(shorts) {
            if (!Array.isArray(shorts)) return false;
            return shorts.some(short => isProcessingStatus(short.status));
        }


        // --- Event Handlers & Actions ---

        // Initial Upload Form Submission
        document.getElementById('uploadForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            const formData = new FormData();
            const videoFile = document.getElementById('video').files[0];
            const subtitleFile = document.getElementById('subtitle').files[0];
            const zoomFactor = document.getElementById('zoomFactor').value; // Get zoom factor value
            const submitButton = e.target.querySelector('button[type="submit"]');
            const uploadStatusEl = document.getElementById('uploadStatus');

            if (!videoFile) {
                setStatus('uploadStatus', 'Please select a video file.', true, 5000);
                return;
            }

            formData.append('video', videoFile);

            // Validate and append zoom factor
            const zoomValue = parseFloat(zoomFactor);
            if (!isNaN(zoomValue) && zoomValue >= 1) {
                formData.append('zoom_factor', zoomValue);
            } // Backend will use default if not provided or invalid

            let statusMsg = 'Uploading video...';

            if (subtitleFile) {
                const allowedExtensions = /(\.srt|\.vtt)$/i;
                if (!allowedExtensions.exec(subtitleFile.name)) {
                    setStatus('uploadStatus', 'Invalid subtitle file type. Please use SRT or VTT.', true, 5000);
                    return;
                }
                formData.append('subtitle', subtitleFile);
                statusMsg = 'Uploading video and subtitle...';
            }

            setStatus('uploadStatus', statusMsg, false, 0); // Persistent status during upload
            submitButton.disabled = true; // Disable button

            try {
                // Use fetchWithCacheBust for consistency, though cache less critical for POST
                const response = await fetchWithCacheBust('/upload', { method: 'POST', body: formData });
                const data = await response.json();

                if (!response.ok) {
                    // Throw error with message from backend if available
                    throw new Error(data.error || `Upload failed with status ${response.status}`);
                }
                // Success message, will disappear after duration
                setStatus('uploadStatus', data.message || `Processing started for video ${data.video_id}...`, false, 10000);
                e.target.reset(); // Clear file inputs on success
                setTimeout(loadAndRenderVideos, 1500); // Refresh videos list slightly sooner after upload starts

            } catch (error) {
                // Persistent error message
                setStatus('uploadStatus', `Upload failed: ${error.message}`, true, 0);
                console.error('Upload error:', error);
            } finally {
                submitButton.disabled = false; // Re-enable button
            }
        });

        // Subtitle Upload for Existing Video
        async function uploadExistingVideoSubtitle(event) {
            event.preventDefault();
            const form = event.target;
            const videoId = form.dataset.videoId;
            const fileInput = form.querySelector('input[name="subtitle"]');
            const submitButton = form.querySelector('button[type="submit"]');
            const file = fileInput.files[0];
            const statusElementId = 'listStatus'; // Use main list status for this action

            if (!file) {
                setStatus(statusElementId, `Please select an SRT or VTT file for video ${videoId}.`, true, 5000);
                return;
            }
            const allowedExtensions = /(\.srt|\.vtt)$/i;
            if (!allowedExtensions.exec(file.name)) {
                setStatus(statusElementId, 'Invalid file type. Please upload an SRT or VTT file.', true, 5000);
                return;
            }

            const formData = new FormData();
            formData.append('subtitle', file);
            setStatus(statusElementId, `Uploading subtitle for video ${videoId}...`, false, 0); // Persistent status
            submitButton.disabled = true;
            fileInput.disabled = true;

            try {
                const response = await fetchWithCacheBust(`/videos/${videoId}/upload_subtitle`, { method: 'POST', body: formData });
                const data = await response.json();
                if (!response.ok) {
                    throw new Error(data.error || `Subtitle upload failed with status ${response.status}`);
                }
                setStatus(statusElementId, data.message || `Subtitle uploaded for video ${videoId}. Reprocessing...`, false, 10000);
                fileInput.value = ''; // Clear file input on success
                setTimeout(loadAndRenderVideos, 1500); // Refresh list to show status change

            } catch (error) {
                setStatus(statusElementId, `Subtitle upload failed: ${error.message}`, true, 0); // Persistent error
                console.error('Subtitle upload error:', error);
                 // Re-enable buttons after error in case it was temporary
                 submitButton.disabled = false;
                 fileInput.disabled = false;
            }
            // No finally block needed here as we want buttons enabled only on error or after refresh confirms state.
            // Refresh triggered above will handle re-enabling based on actual video status.
        }

        // Trigger "Reprocess All (Force Use Subs)"
        async function triggerReprocessWithSubs(videoId) {
             const video = videosData[videoId];
             if (!video || !video.uploaded_subtitle_filename) {
                 setStatus('listStatus', 'No uploaded subtitle found to force reprocess with.', true, 5000);
                 return;
             }
             if (!['completed', 'failed'].includes(video.status)) {
                  setStatus('listStatus', `Video must be 'completed' or 'failed' to trigger reprocess. Current: ${video.status}.`, true, 5000);
                  return;
             }

             if (!confirm(`Force re-processing video ${videoId} using subtitle:\n${video.uploaded_subtitle_filename}\n\nThis will overwrite the edited video and regenerate suggestions.\nContinue?`)) return;

             setStatus('listStatus', `Requesting reprocess (using subs) for video ${videoId}...`, false, 0);
             // Disable relevant buttons on the row temporarily
             const row = document.querySelector(`tr[data-video-id="${videoId}"]`);
             const buttons = row ? row.querySelectorAll('button') : [];
             buttons.forEach(btn => btn.disabled = true);

             try {
                 const response = await fetchWithCacheBust(`/videos/${videoId}/reprocess_with_subtitle_trigger`, { method: 'POST' });
                 const data = await response.json();
                 if (!response.ok) {
                     throw new Error(data.error || 'Failed to trigger reprocess');
                 }
                 setStatus('listStatus', data.message || `Reprocessing (using subs) started for video ${videoId}.`, false, 10000);
                 setTimeout(loadAndRenderVideos, 1500); // Refresh list soon

             } catch (error) {
                 setStatus('listStatus', `Failed to trigger reprocess: ${error.message}`, true, 0); // Persistent error
                 console.error('Error triggering reprocess with subs:', error);
                 // Re-enable buttons on error
                 buttons.forEach(btn => btn.disabled = false); // Simple re-enable, refresh will correct state later
             }
        }

        // Trigger "Reprocess Suggestions"
        async function reprocessSuggestions(videoId) {
             const video = videosData[videoId];
             if (!video) return;

             if (video.status !== 'completed') {
                 setStatus('listStatus', `Video status is ${video.status}. Suggestions require 'completed' status.`, true, 5000);
                 return;
             }
             if (!video.has_subtitle_content) {
                  setStatus('listStatus', 'No subtitle content found for this video. Cannot regenerate suggestions.', true, 5000);
                  return;
             }

             const confirmMessage = 'Regenerate short suggestions using the current subtitle content?\nExisting pending/failed suggestions will be replaced. Completed shorts remain.';
             if (!confirm(confirmMessage)) return;

             setStatus('listStatus', `Requesting suggestion regeneration for video ${videoId}...`, false, 0);
             const button = event.target; // Get the button that was clicked
             if (button) button.disabled = true;

             try {
                 // Use the '/refresh' endpoint for suggestion regeneration
                 const response = await fetchWithCacheBust(`/videos/${videoId}/refresh`, { method: 'POST' });
                 const data = await response.json();
                 if (!response.ok) {
                     throw new Error(data.error || 'Failed to start suggestion regeneration.');
                 }
                 setStatus('listStatus', data.message || `Suggestion regeneration started for video ${videoId}.`, false, 10000);

                 // Refresh list AND modal content after a delay
                 setTimeout(async () => {
                      await loadAndRenderVideos(); // Refresh main list
                      if (currentModalVideoId === videoId) { // If modal is open for this video
                           console.log(`Modal open for video ${videoId}, refreshing its content after suggestion request.`);
                           const shorts = await fetchShortsForVideo(videoId); // Fetch fresh shorts
                           videosData[videoId].shorts = shorts; // Update cache
                           updateShortsModal(videoId); // Update modal UI
                      }
                 }, REFRESH_INTERVAL_MS); // Wait a bit longer for suggestions task to potentially start

             } catch (error) {
                 setStatus('listStatus', `Error regenerating suggestions: ${error.message}`, true, 0); // Persistent error
                 console.error('Error regenerating suggestions:', error);
                 if (button) button.disabled = false; // Re-enable on error
             }
         }

         // Trigger "Reprocess All (Auto-Detect Subs)"
         async function reprocessAllAutoDetect(videoId) {
              const video = videosData[videoId];
              if (!video) return;

              if (!['completed', 'failed'].includes(video.status)) {
                  setStatus('listStatus', `Video must be 'completed' or 'failed' to reprocess. Current: ${video.status}.`, true, 5000);
                  return;
              }

              const subtitleSourceMessage = video.uploaded_subtitle_filename
                  ? `using uploaded subtitle: ${video.uploaded_subtitle_filename}`
                  : 'generating subtitles if needed';

              const confirmMessage = `Re-process video ${videoId} entirely?\nThis will re-process subtitles (${subtitleSourceMessage}), re-edit the video, and regenerate suggestions.\nContinue?`;
              if (!confirm(confirmMessage)) return;

              setStatus('listStatus', `Requesting full reprocessing for video ${videoId}...`, false, 0);
              const button = event.target;
              if (button) button.disabled = true;

              try {
                  const response = await fetchWithCacheBust(`/videos/${videoId}/reprocess_subtitles`, { method: 'POST' });
                  const data = await response.json();
                  if (!response.ok) {
                      throw new Error(data.error || 'Failed to trigger full reprocess.');
                  }
                  setStatus('listStatus', data.message || `Full reprocessing started for video ${videoId}.`, false, 10000);
                  setTimeout(loadAndRenderVideos, 1500); // Refresh list soon

              } catch (error) {
                  setStatus('listStatus', `Failed to trigger full reprocess: ${error.message}`, true, 0); // Persistent error
                  console.error('Error triggering full reprocess:', error);
                  if (button) button.disabled = false; // Re-enable on error
              }
          }

        // --- Modal Management ---
        async function showShorts(videoId) {
            const video = videosData[videoId];
            // Allow opening even if processing, but content will reflect status
            if (!video) {
                setStatus('listStatus', 'Video data not found.', true, 5000);
                return;
            }

            currentModalVideoId = videoId; // Track which modal is open
            document.getElementById('shortsModalTitle').textContent = `Shorts for: ${video.title || video.original_filename}`;
            setStatus('shortsModalStatus', 'Loading shorts data...', false, 0);
            document.getElementById('shortsModal').style.display = 'block';
            document.body.style.overflow = 'hidden'; // Prevent background scroll

            // Initial fetch and render for the modal
            const shorts = await fetchShortsForVideo(videoId);
            // Ensure local cache has shorts array initialized if needed
            if (!videosData[videoId].shorts) videosData[videoId].shorts = [];
            videosData[videoId].shorts = shorts; // Update cache with fetched data
            updateShortsModal(videoId); // Render modal content
            // Status is cleared/updated by fetchShortsForVideo

            // Start periodic refresh ONLY if needed (video or shorts processing)
            clearAndSetRefreshInterval(); // Start interval checks
        }

        // --- Interval Logic ---
        function clearAndSetRefreshInterval() {
             // Clear any existing interval
             if (refreshIntervalId) {
                 clearInterval(refreshIntervalId);
                 refreshIntervalId = null;
                 console.log("Cleared existing modal refresh interval.");
             }

             // Set a new interval ONLY if a modal is open
             if (currentModalVideoId) {
                 console.log(`Setting refresh interval for modal video ${currentModalVideoId}`);
                 refreshIntervalId = setInterval(async () => {
                     // Double-check if the modal should still be refreshing
                     if (!currentModalVideoId || !videosData[currentModalVideoId]) {
                         console.log("Modal closed or video removed, stopping interval.");
                         clearInterval(refreshIntervalId);
                         refreshIntervalId = null;
                         return;
                     }

                     const video = videosData[currentModalVideoId];
                     console.log(`Interval check: Modal video ${currentModalVideoId}, status: ${video.status}, shorts count: ${video.shorts?.length || 0}`);

                     // Determine if a refresh of video/shorts data is needed
                     const needsRefresh = isProcessingStatus(video.status) || shouldRefreshShorts(video.shorts);
                     // Also refresh if video just completed and might now have suggestible content without shorts
                     const justCompletedAndSuggestible = video.status === 'completed' && video.has_subtitle_content && (!video.shorts || video.shorts.length === 0);

                     if (needsRefresh || justCompletedAndSuggestible) {
                         console.log("Interval: Refresh needed, calling loadAndRenderVideos.");
                         await loadAndRenderVideos(); // This will fetch videos and update modal if necessary
                     } else {
                         console.log("Interval: No refresh needed.");
                         // Ensure status message is cleared if everything is stable/completed
                         const statusElement = document.getElementById('shortsModalStatus');
                         if (statusElement && (statusElement.textContent.includes('Waiting') || statusElement.textContent.includes('Refreshing'))) {
                            setStatus('shortsModalStatus', '');
                         }
                         // Optional: Could stop the interval if nothing is processing anymore
                         // clearInterval(refreshIntervalId);
                         // refreshIntervalId = null;
                         // console.log("Interval: Stable state reached, stopping interval.");
                     }

                 }, REFRESH_INTERVAL_MS);
             } else {
                 console.log("No current modal video ID, interval not set.");
             }
        }

        // --- Update Modal UI ---
        function updateShortsModal(videoId) {
             const video = videosData[videoId];
             if (!video) {
                 console.warn(`updateShortsModal called for non-existent videoId: ${videoId}`);
                 closeShortsModal(); // Close if video data is gone
                 return;
             }

             const shorts = Array.isArray(video.shorts) ? video.shorts : [];
             const shortsList = document.getElementById('shortsList');
             shortsList.innerHTML = ''; // Clear previous list items
             const hasSuggestibleContent = video.has_subtitle_content === true;

             // --- Handle Different Video States ---
             if (isProcessingStatus(video.status)) {
                 shortsList.innerHTML = `<p>Main video is currently ${video.status}. Shorts management unavailable.</p>`;
                 // Status message is handled by the interval/load function
                 return;
             }
             if (video.status === 'failed') {
                  shortsList.innerHTML = `<p>Main video processing failed. Shorts management unavailable.</p>`;
                  // Status message is handled by the interval/load function
                  return;
             }

             // --- Handle Empty Shorts List (Video Completed) ---
             if (video.status === 'completed' && shorts.length === 0) {
                 if (hasSuggestibleContent) {
                     // Provide button to trigger initial suggestion
                     shortsList.innerHTML = `<p>No shorts suggested yet.</p><button onclick="reprocessSuggestions(${videoId})">Suggest Shorts Now</button>`;
                 } else {
                      // No content to suggest from
                      shortsList.innerHTML = '<p>No shorts created yet, and no subtitle content found to generate suggestions.</p>';
                 }
                 return; // Stop here if no shorts to display
             }

             // --- Render Shorts Items (Video Completed) ---
             // Sort by start time for consistent order
             shorts.sort((a, b) => {
                 // Basic time string comparison (works for H:MM:SS)
                 return (a.start_time || "").localeCompare(b.start_time || "");
             });

             shorts.forEach(short => {
                 const shortIsProcessing = isProcessingStatus(short.status);
                 const shortIsCompleted = short.status === 'completed';
                 const shortIsFailed = short.status === 'failed';
                 const shortIsPending = short.status === 'pending'; // Initial state after suggestion

                 const canCreate = shortIsPending || shortIsFailed; // Can create if pending or failed
                 const canRecreate = shortIsCompleted || shortIsFailed; // Can recreate if completed or failed
                 const canPlay = shortIsCompleted && !!short.short_url;
                 const canUpdateTimes = !shortIsProcessing; // Can update times unless actively processing

                 const shortDiv = document.createElement('div');
                 shortDiv.className = 'short-item';
                 shortDiv.dataset.shortId = short.id; // Store ID for actions

                 shortDiv.innerHTML = `
                     <div class="short-info">
                         <p><strong>${short.short_name || `Short ${short.id}`}</strong></p>
                         ${short.short_description ? `<p><small>${short.short_description}</small></p>` : ''}
                         <p>Status: <strong class="${getVideoStatusClass(short.status)}">${short.status}</strong></p>
                         ${shortIsFailed && short.error_message ? `<p><small style="color: var(--danger-color);">Error: ${short.error_message}</small></p>` : ''}
                     </div>
                     <div class="short-time short-time-inputs">
                         <label for="start-${short.id}">Start:</label>
                         <input type="text" value="${short.start_time || ''}" id="start-${short.id}" pattern="\\d{1,3}:\\d{2}:\\d{2}(\\.\\d+)?" title="H:MM:SS or HH:MM:SS or H:MM:SS.ms" ${!canUpdateTimes ? 'disabled' : ''}>
                         <label for="end-${short.id}">End:</label>
                         <input type="text" value="${short.end_time || ''}" id="end-${short.id}" pattern="\\d{1,3}:\\d{2}:\\d{2}(\\.\\d+)?" title="H:MM:SS or HH:MM:SS or H:MM:SS.ms" ${!canUpdateTimes ? 'disabled' : ''}>
                         <button onclick="updateShort(${videoId}, ${short.id})" title="Save time changes (resets status to pending if completed)" ${!canUpdateTimes ? 'disabled' : ''}>Update Times</button>
                     </div>
                     <div class="short-actions">
                         <button onclick="createShort(${videoId}, ${short.id})" ${!canCreate ? 'disabled' : ''} title="${canCreate ? 'Generate this short video' : (shortIsProcessing ? 'Processing...' : 'Already created')}">
                            ${shortIsFailed ? 'Retry Create' : 'Create'}
                         </button>
                         <button onclick="recreateShort(${videoId}, ${short.id})" ${!canRecreate ? 'disabled' : ''} title="${canRecreate ? 'Re-generate this short video (overwrites existing)' : (shortIsProcessing ? 'Processing...' : 'Create first')}">
                             Recreate
                         </button>
                         <button onclick="playVideo('${short.short_url}', 'Short: ${(short.short_name || `Short ${short.id}`).replace(/'/g, "\\'")}')" ${!canPlay ? 'disabled' : ''} title="${canPlay ? 'Play the generated short' : (shortIsProcessing ? 'Processing...' : 'Short not ready or URL missing')}">
                             Play Short
                         </button>
                         <!-- <button class="danger" onclick="deleteShort(${videoId}, ${short.id})" title="Delete this short (Not Implemented)">Delete Short</button> -->
                     </div>
                 `;
                 shortsList.appendChild(shortDiv);
             });

             // --- Add "Suggest More" Button (if applicable) ---
             if (video.status === 'completed' && hasSuggestibleContent) {
                   const suggestMoreButton = document.createElement('button');
                   suggestMoreButton.textContent = 'Suggest More Shorts';
                   suggestMoreButton.onclick = () => reprocessSuggestions(videoId); // Reuse the regenerate function
                   suggestMoreButton.title = 'Generate additional suggestions (may replace pending/failed ones)';
                   suggestMoreButton.style.marginTop = '20px'; // Space above the button
                   shortsList.appendChild(suggestMoreButton);
             }
         }


        // --- Close Modals ---
        function closeModal(modalId) {
             const modal = document.getElementById(modalId);
             if (modal) modal.style.display = 'none';
             document.body.style.overflow = 'auto'; // Restore background scroll

             // If closing shorts modal, clear interval and reset tracking ID
             if (modalId === 'shortsModal') {
                 console.log("Closing shorts modal, clearing interval.");
                 if (refreshIntervalId) {
                     clearInterval(refreshIntervalId);
                     refreshIntervalId = null;
                 }
                 currentModalVideoId = null; // Reset tracking ID
                 const list = document.getElementById('shortsList');
                 if (list) list.innerHTML = ''; // Clear content
                 setStatus('shortsModalStatus', ''); // Clear status
                 // Debounce main list refresh to avoid rapid updates if closed/opened quickly
                 debouncedLoadAndRender();
             }
             // If closing video modal, pause video
             if (modalId === 'videoModal') {
                  const video = document.getElementById('modalVideo');
                  if (video) {
                      video.pause();
                      video.removeAttribute('src'); // Release the source
                      video.load(); // Reset
                  }
                  document.getElementById('videoModalTitle').textContent = 'Video Player'; // Reset title
             }
         }

        function closeShortsModal() { closeModal('shortsModal'); }
        function closeVideoModal() { closeModal('videoModal'); }

        // --- Short Action Functions ---
        async function performShortAction(url, videoId, shortId, actionName) {
             setStatus('shortsModalStatus', `${actionName} short ${shortId}...`, false, 0); // Persistent status

             // Find the specific short item div and disable its buttons
             const shortItemDiv = document.querySelector(`#shortsList .short-item[data-short-id='${shortId}']`);
             const buttons = shortItemDiv ? shortItemDiv.querySelectorAll('button') : [];
             buttons.forEach(btn => btn.disabled = true);

             try {
                 const response = await fetchWithCacheBust(url, { method: 'POST' });
                 const data = await response.json();
                 if (!response.ok) {
                     throw new Error(data.error || `${actionName} failed with status ${response.status}`);
                 }
                 // Display success message briefly, interval will update status correctly
                 setStatus('shortsModalStatus', data.message || `${actionName} started for short ${shortId}. Status will update.`, false, 7000);

                 // Optimistic UI update: Set status to 'queued' locally and re-render modal
                 const shortIndex = videosData[videoId]?.shorts.findIndex(s => s.id === shortId);
                 if (shortIndex > -1 && videosData[videoId].shorts[shortIndex].status !== 'queued') {
                      videosData[videoId].shorts[shortIndex].status = 'queued'; // Assume it's queued
                      updateShortsModal(videoId); // Re-render modal immediately
                 }
                 // No need to manually re-enable buttons here, the next refresh interval will fetch the true state.
                 // Ensure interval is running
                 clearAndSetRefreshInterval();

             } catch (error) {
                 setStatus('shortsModalStatus', `${actionName} failed: ${error.message}`, true, 0); // Persistent error
                 console.error(`Error ${actionName} short ${shortId}:`, error);
                 // Force a fetch after a short delay to get the accurate 'failed' status from backend
                 setTimeout(async () => {
                     if (currentModalVideoId === videoId) { // Only if modal still relevant
                         const shorts = await fetchShortsForVideo(videoId);
                         videosData[videoId].shorts = shorts;
                         updateShortsModal(videoId); // Re-render with correct status/button states
                     }
                 }, 1500); // Delay before fetching state after error
             }
        }

        function createShort(videoId, shortId) {
            performShortAction(`/videos/${videoId}/shorts/${shortId}/create`, videoId, shortId, 'Creating');
        }

        function recreateShort(videoId, shortId) {
             if (confirm('Recreate this short?\nThe existing file (if any) will be overwritten.')) {
                  performShortAction(`/videos/${videoId}/shorts/${shortId}/recreate`, videoId, shortId, 'Recreating');
             }
        }

        async function updateShort(videoId, shortId) {
            const startTimeInput = document.getElementById(`start-${shortId}`);
            const endTimeInput = document.getElementById(`end-${shortId}`);
            // Find the button within the same time div
            const updateButton = startTimeInput.closest('.short-time').querySelector('button');
            const startTime = startTimeInput.value.trim();
            const endTime = endTimeInput.value.trim();

            // Relaxed pattern allowing H:MM:SS or H:MM:SS.ms
            const timePattern = /^\d{1,3}:\d{2}:\d{2}(\.\d+)?$/;
            if (!timePattern.test(startTime) || !timePattern.test(endTime)) {
                setStatus('shortsModalStatus', 'Invalid time format. Use H:MM:SS or H:MM:SS.ms.', true, 5000);
                return;
            }

            // Convert to seconds for comparison (ignoring milliseconds for comparison)
            const timeToSec = (t) => {
                const parts = t.split('.')[0].split(':'); // Ignore ms part for comparison
                return parts.reduce((acc, time) => (60 * acc) + parseInt(time, 10), 0);
            }
             try {
                  if (timeToSec(startTime) >= timeToSec(endTime)) {
                      setStatus('shortsModalStatus', 'Start time must be before end time.', true, 5000);
                      return;
                  }
             } catch (e) {
                  setStatus('shortsModalStatus', 'Invalid time value entered.', true, 5000);
                  return;
             }

             setStatus('shortsModalStatus', `Updating times for short ${shortId}...`, false, 0); // Persistent
             if(updateButton) updateButton.disabled = true;

             try {
                  const response = await fetchWithCacheBust(`/videos/${videoId}/shorts/${shortId}/update`, {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ start_time: startTime, end_time: endTime })
                  });
                  const data = await response.json();
                  if (!response.ok) {
                      throw new Error(data.error || 'Failed to update short times.');
                  }
                  setStatus('shortsModalStatus', data.message || 'Short times updated successfully. Status reset to pending.', false, 7000);

                   // Update local cache with the *returned* short data (which should include updated status)
                   if (data.short) {
                       const shortIndex = videosData[videoId]?.shorts.findIndex(s => s.id === shortId);
                       if (shortIndex > -1) {
                            // Replace the old short data with the new data from the server
                            videosData[videoId].shorts[shortIndex] = data.short;
                       }
                       updateShortsModal(videoId); // Re-render modal with updated cache
                   } else {
                        // Fallback: If backend didn't return updated short, force a refresh
                        console.warn("Backend didn't return updated short data, forcing refresh.");
                        const shorts = await fetchShortsForVideo(videoId);
                        videosData[videoId].shorts = shorts;
                        updateShortsModal(videoId);
                   }

             } catch (error) {
                  setStatus('shortsModalStatus', `Update failed: ${error.message}`, true, 0); // Persistent error
                  console.error('Error updating short:', error);
                  // Re-enable button on error
                  if(updateButton) updateButton.disabled = false;
             }
        }

        // --- Video Player ---
        function playVideo(url, title = 'Video Player') {
            if (url && url !== 'null' && url !== 'undefined') {
                // Escape HTML entities in the title before setting it as textContent
                const escapedTitle = title.replace(/</g, "<").replace(/>/g, ">");
                document.getElementById('videoModalTitle').textContent = escapedTitle;
                const videoElement = document.getElementById('modalVideo');
                // Add cache buster to video URL to ensure fresh playback
                const separator = url.includes('?') ? '&' : '?';
                videoElement.src = `${url}${separator}_=${new Date().getTime()}`;
                document.getElementById('videoModal').style.display = 'block';
                document.body.style.overflow = 'hidden'; // Prevent background scroll
                videoElement.play().catch(e => console.warn("Autoplay may be blocked by browser:", e));
            } else {
                setStatus('listStatus', 'Video URL is not available for playback.', true, 5000);
            }
        }
        // closeVideoModal is handled by closeModal('videoModal')


        // --- Delete Video ---
        async function deleteVideo(videoId) {
            const video = videosData[videoId];
            const videoTitle = video ? (video.title || video.original_filename) : `ID ${videoId}`;

            // Enhanced confirmation message
            if (!confirm(`DELETE Video: ${videoTitle}?\n\nWARNING: This permanently removes:\n- Original video file\n- Edited video file\n- Uploaded subtitle file\n- All generated short video files\n- All database records for this video and its shorts.\n\nThis action CANNOT be undone.`)) {
                 return;
            }

            setStatus('listStatus', `Deleting video ${videoTitle}...`, false, 0); // Persistent status
            // Disable buttons on the row being deleted
            const row = document.querySelector(`tr[data-video-id="${videoId}"]`);
            const buttons = row ? row.querySelectorAll('button') : [];
            buttons.forEach(btn => btn.disabled = true);


            try {
                 const response = await fetchWithCacheBust(`/videos/${videoId}`, { method: 'DELETE' });
                 const data = await response.json();
                 if (!response.ok) {
                     throw new Error(data.error || 'Failed to delete video.');
                 }
                 setStatus('listStatus', data.message || `Video ${videoTitle} deleted successfully.`, false, 10000);

                 // Remove from local data immediately and re-render table
                 delete videosData[videoId];
                 renderVideosTable(Object.values(videosData)); // Re-render with remaining videos

                 // If the deleted video's modal was open, close it
                 if (currentModalVideoId === videoId) {
                     closeShortsModal(); // This handles cleanup for the shorts modal
                 }

            } catch (error) {
                 setStatus('listStatus', `Deletion failed: ${error.message}`, true, 0); // Persistent error
                 console.error('Error deleting video:', error);
                 // Re-enable buttons on the row if deletion failed
                 buttons.forEach(btn => btn.disabled = false);
                 // Optionally trigger a refresh to get the latest state from the server
                 setTimeout(loadAndRenderVideos, 1500);
            }
        }

        // --- Initial Load & Global Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            loadAndRenderVideos(); // Initial load of video list
        });

        // Close modals on background click (click outside content)
         window.addEventListener('click', function(event) {
             const videoModal = document.getElementById('videoModal');
             const shortsModal = document.getElementById('shortsModal');
             if (event.target == videoModal) { // Clicked on the semi-transparent background
                 closeVideoModal();
             }
             if (event.target == shortsModal) { // Clicked on the semi-transparent background
                 closeShortsModal();
             }
         });

          // Close modals on Escape key press
          window.addEventListener('keydown', function(event) {
               if (event.key === 'Escape' || event.key === 'Esc') { // Check for both Escape and Esc
                    // Close the topmost modal first
                    if (document.getElementById('videoModal').style.display === 'block') {
                         closeVideoModal();
                    } else if (document.getElementById('shortsModal').style.display === 'block') {
                         closeShortsModal();
                    }
               }
          });

    </script>
</body>
</html>